
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Spike Sorting by Clustering &#8212; Machine Learning Methods for Neural Data Analysis</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"mba": "\\boldsymbol{a}", "mbb": "\\boldsymbol{b}", "mbc": "\\boldsymbol{c}", "mbd": "\\boldsymbol{d}", "mbe": "\\boldsymbol{e}", "mbf": "\\boldsymbol{f}", "mbg": "\\boldsymbol{g}", "mbh": "\\boldsymbol{h}", "mbi": "\\boldsymbol{i}", "mbj": "\\boldsymbol{j}", "mbk": "\\boldsymbol{k}", "mbl": "\\boldsymbol{l}", "mbm": "\\boldsymbol{m}", "mbn": "\\boldsymbol{n}", "mbo": "\\boldsymbol{o}", "mbp": "\\boldsymbol{p}", "mbq": "\\boldsymbol{q}", "mbr": "\\boldsymbol{r}", "mbs": "\\boldsymbol{s}", "mbt": "\\boldsymbol{t}", "mbu": "\\boldsymbol{u}", "mbv": "\\boldsymbol{v}", "mbw": "\\boldsymbol{w}", "mbx": "\\boldsymbol{x}", "mby": "\\boldsymbol{y}", "mbz": "\\boldsymbol{z}", "mbA": "\\boldsymbol{A}", "mbB": "\\boldsymbol{B}", "mbC": "\\boldsymbol{C}", "mbD": "\\boldsymbol{D}", "mbE": "\\boldsymbol{E}", "mbF": "\\boldsymbol{F}", "mbG": "\\boldsymbol{G}", "mbH": "\\boldsymbol{H}", "mbI": "\\boldsymbol{I}", "mbJ": "\\boldsymbol{J}", "mbK": "\\boldsymbol{K}", "mbL": "\\boldsymbol{L}", "mbM": "\\boldsymbol{M}", "mbN": "\\boldsymbol{N}", "mbO": "\\boldsymbol{O}", "mbP": "\\boldsymbol{P}", "mbQ": "\\boldsymbol{Q}", "mbR": "\\boldsymbol{R}", "mbS": "\\boldsymbol{S}", "mbT": "\\boldsymbol{T}", "mbU": "\\boldsymbol{U}", "mbV": "\\boldsymbol{V}", "mbW": "\\boldsymbol{W}", "mbX": "\\boldsymbol{X}", "mbY": "\\boldsymbol{Y}", "mbZ": "\\boldsymbol{Z}", "bbA": "\\mathbb{A}", "bbB": "\\mathbb{B}", "bbC": "\\mathbb{C}", "bbD": "\\mathbb{D}", "bbE": "\\mathbb{E}", "bbG": "\\mathbb{G}", "bbH": "\\mathbb{H}", "bbI": "\\mathbb{I}", "bbJ": "\\mathbb{J}", "bbK": "\\mathbb{K}", "bbL": "\\mathbb{L}", "bbM": "\\mathbb{M}", "bbN": "\\mathbb{N}", "bbO": "\\mathbb{O}", "bbP": "\\mathbb{P}", "bbQ": "\\mathbb{Q}", "bbR": "\\mathbb{R}", "bbS": "\\mathbb{S}", "bbT": "\\mathbb{T}", "bbU": "\\mathbb{U}", "bbV": "\\mathbb{V}", "bbW": "\\mathbb{W}", "bbX": "\\mathbb{X}", "bbY": "\\mathbb{Y}", "bbZ": "\\mathbb{Z}", "cA": "\\mathcal{A}", "cB": "\\mathcal{B}", "cC": "\\mathcal{C}", "cD": "\\mathcal{D}", "cE": "\\mathcal{E}", "cG": "\\mathcal{G}", "cH": "\\mathcal{H}", "cI": "\\mathcal{I}", "cJ": "\\mathcal{J}", "cK": "\\mathcal{K}", "cL": "\\mathcal{L}", "cM": "\\mathcal{M}", "cN": "\\mathcal{N}", "cO": "\\mathcal{O}", "cP": "\\mathcal{P}", "cQ": "\\mathcal{Q}", "cR": "\\mathcal{R}", "cS": "\\mathcal{S}", "cT": "\\mathcal{T}", "cU": "\\mathcal{U}", "cV": "\\mathcal{V}", "cW": "\\mathcal{W}", "cX": "\\mathcal{X}", "cY": "\\mathcal{Y}", "cZ": "\\mathcal{Z}", "mbalpha": "\\boldsymbol{\\alpha}", "mbbeta": "\\boldsymbol{\\beta}", "mbgamma": "\\boldsymbol{\\gamma}", "mbdelta": "\\boldsymbol{\\delta}", "mbepsilon": "\\boldsymbol{\\epsilon}", "mbchi": "\\boldsymbol{\\chi}", "mbeta": "\\boldsymbol{\\eta}", "mbiota": "\\boldsymbol{\\iota}", "mbkappa": "\\boldsymbol{\\kappa}", "mblambda": "\\boldsymbol{\\lambda}", "mbmu": "\\boldsymbol{\\mu}", "mbnu": "\\boldsymbol{\\nu}", "mbomega": "\\boldsymbol{\\omega}", "mbtheta": "\\boldsymbol{\\theta}", "mbphi": "\\boldsymbol{\\phi}", "mbpi": "\\boldsymbol{\\pi}", "mbpsi": "\\boldsymbol{\\psi}", "mbrho": "\\boldsymbol{\\rho}", "mbsigma": "\\boldsymbol{\\sigma}", "mbtau": "\\boldsymbol{\\tau}", "mbupsilon": "\\boldsymbol{\\upsilon}", "mbxi": "\\boldsymbol{\\xi}", "mbzeta": "\\boldsymbol{\\zeta}", "mbvarepsilon": "\\boldsymbol{\\varepsilon}", "mbvarphi": "\\boldsymbol{\\varphi}", "mbvartheta": "\\boldsymbol{\\vartheta}", "mbvarrho": "\\boldsymbol{\\varrho}", "mbDelta": "\\boldsymbol{\\Delta}", "mbGamma": "\\boldsymbol{\\Gamma}", "mbLambda": "\\boldsymbol{\\Lambda}", "mbOmega": "\\boldsymbol{\\Omega}", "mbPhi": "\\boldsymbol{\\Phi}", "mbPsi": "\\boldsymbol{\\Psi}", "mbPi": "\\boldsymbol{\\Pi}", "mbSigma": "\\boldsymbol{\\Sigma}", "mbTheta": "\\boldsymbol{\\Theta}", "mbUpsilon": "\\boldsymbol{\\Upsilon}", "mbXi": "\\boldsymbol{\\Xi}", "mbzero": "\\boldsymbol{0}", "mbone": "\\boldsymbol{1}", "iid": ["\\stackrel{\\text{iid}}{#1}", 1], "ind": ["\\stackrel{\\text{ind}}{#1}", 1], "dif": "\\mathop{}\\!\\mathrm{d}", "diag": "\\textrm{diag}", "supp": "\\textrm{supp}", "Tr": "\\textrm{Tr}", "E": "\\mathbb{E}", "Var": "\\textrm{Var}", "Cov": "\\textrm{Cov}", "reals": "\\mathbb{R}", "naturals": "\\mathbb{N}", "KL": ["D_{\\textrm{KL}}\\left(#1\\;\\|\\;#2\\right)", 2]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'labs/01a_spike_sorting';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Spike Sorting by Deconvolution" href="01b_spike_sorting_deconv.html" />
    <link rel="prev" title="PyTorch Primer" href="00_pytorch_primer.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Machine Learning Methods for Neural Data Analysis</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Introduction
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Foundations</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapters/02_probabilistic_modeling.html">Probabilistic Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/03_neurobio.html">Basic Neurobiology</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Unit I: Signal Extraction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapters/04a_spike_sorting_clustering.html">Spike Sorting by Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/04b_simple_spike_sorting.html">Spike Sorting by Matrix Factorization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/05_deconv_spike_sorting.html">Spike Sorting by Deconvolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/06_calcium_imaging.html">Demixing Calcium Imaging Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/07_pose_tracking.html">Markerless Pose Tracking</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Unit II: Encoding &amp; Decoding</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapters/08_summary_stats.html">Summary Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/09_glm.html">Generalized Linear Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/10_poisson_processes.html">Poisson Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/11_decoding.html">Decoding Models</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Unit III: Unsupervised Learning</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapters/12_mixtures_em.html">Mixture Models and the EM Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/13_hmms.html">Hidden Markov Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/16_poldrack_fmri_analysis.html">fMRI Analysis</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Labs</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="00_pytorch_primer.html">PyTorch Primer</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Spike Sorting by Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="01b_spike_sorting_deconv.html">Spike Sorting by Deconvolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_calcium_imaging.html">Calcium Deconvolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_pose_tracking.html">Markerless Pose Tracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_glms.html">Generalized Linear Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_decoding.html">Bayesian Decoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_arhmm.html">Autoregressive HMMs</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_slds.html">Switching LDS</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_lfads.html">Sequential Variational Autoencoders</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapters/99_references.html">References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/slinderman/ml4nd/blob/main/labs/01a_spike_sorting.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Colab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Colab logo" src="../_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/labs/01a_spike_sorting.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Spike Sorting by Clustering</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setup">Setup</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#load-the-data">Load the data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#helper-functions">Helper functions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-1-infer-spike-times">Part 1: Infer spike times</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-1a-find-negative-peaks-in-the-data">Problem 1a: Find negative peaks in the data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-1b-evaluate-the-inferred-spike-times">Problem 1b: Evaluate the inferred spike times</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#collect-the-voltage-traces-surrounding-each-inferred-spike">Collect the voltage traces surrounding each inferred spike</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-2-simple-spike-sorting">Part 2: Simple Spike Sorting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2a-deriving-the-fitting-algorithm">Problem 2a: Deriving the fitting algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2b-updating-the-spike-assignments">Problem 2b: Updating the spike assignments</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2c-implement-the-model-and-algorithm">Problem 2c: Implement the model and algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compare-ids-of-the-true-neurons-that-match-each-inferred-spike">Compare IDs of the true neurons that match each inferred spike</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2d-compare-the-true-and-inferred-spike-assignments">Problem 2d: Compare the true and inferred spike assignments</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-3-generalizations">Part 3: Generalizations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#submission-instructions">Submission Instructions</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="spike-sorting-by-clustering">
<h1>Spike Sorting by Clustering<a class="headerlink" href="#spike-sorting-by-clustering" title="Link to this heading">#</a></h1>
<p>In this lab you’ll build a basic spike sorting algorithm for electrophysiological recordings like those you might collect with a tetrode. The model is inspired by <a class="reference external" href="https://github.com/flatironinstitute/mountainsort5">MountainSort</a>, a popular spike sorting algorithm. We’ll fit the model to synthetic data simulated with <a class="reference external" href="https://github.com/SpikeInterface/spikeinterface">SpikeInterface</a>, a tool that can generate realistic data with ground truth spike times.</p>
<section id="setup">
<h2>Setup<a class="headerlink" href="#setup" title="Link to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Install dependencies</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">jaxtyping</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="o">!</span>pip<span class="w"> </span>install<span class="w"> </span>jaxtyping
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, import necessary libraries.</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">signal</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.distributions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dist</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">jaxtyping</span><span class="w"> </span><span class="kn">import</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Int</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span>
</pre></div>
</div>
</div>
</div>
<section id="load-the-data">
<h3>Load the data<a class="headerlink" href="#load-the-data" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># %%capture</span>
<span class="c1"># !wget -nc https://www.dropbox.com/s/tq0auevkswaa09y/sim_binary.imec.ap.bin</span>
<span class="c1"># !wget -nc https://www.dropbox.com/s/j0xcqk7v9n0fzc7/eMouseGroundTruth.mat</span>
<span class="o">!</span>cp<span class="w"> </span>../data/01_simple_spike_sorting/lab01_data.pt<span class="w"> </span>.<span class="w"> </span>
</pre></div>
</div>
</div>
</div>
<p>The data has four fields:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">traces</span></code>: A <span class="math notranslate nohighlight">\(T \times C\)</span> tensor of voltage measurements (in microvolts) over <span class="math notranslate nohighlight">\(T\)</span> time steps and <span class="math notranslate nohighlight">\(C\)</span> recording channels</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">true_spike_times</span></code>: A length <span class="math notranslate nohighlight">\(S\)</span> tensor of spike times (in the range <span class="math notranslate nohighlight">\(0, \ldots, T-1\)</span>) corresponding to when spikes truly happened in this simulated dataset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">true_spike_ids</span></code>: A length <span class="math notranslate nohighlight">\(S\)</span> tensor of spike IDs (in the range <span class="math notranslate nohighlight">\(0,\ldots, N-1\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> denotes the number of neurons) representing which neuron produced the corresponding spike</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sampling_frequency</span></code>: The sampling frequency of the recording (in Hz)</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;lab01_data.pt&quot;</span><span class="p">)</span>
<span class="n">traces</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;traces&quot;</span><span class="p">]</span>
<span class="n">true_spike_times</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;true_spike_times&quot;</span><span class="p">]</span>
<span class="n">true_spike_ids</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;true_spike_ids&quot;</span><span class="p">]</span>
<span class="n">true_templates</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;true_templates&quot;</span><span class="p">]</span>

<span class="c1"># Extract scalar constants </span>
<span class="n">SAMPLING_FREQUENCY</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sampling_frequency&quot;</span><span class="p">]</span>
<span class="n">NUM_SAMPLES</span><span class="p">,</span> <span class="n">NUM_CHANNELS</span> <span class="o">=</span> <span class="n">traces</span><span class="o">.</span><span class="n">shape</span>
<span class="n">TRUE_NUM_SPIKES</span> <span class="o">=</span> <span class="n">true_spike_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">TRUE_NUM_NEURONS</span><span class="p">,</span> <span class="n">WINDOW_SIZE</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">true_templates</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="helper-functions">
<h3>Helper functions<a class="headerlink" href="#helper-functions" title="Link to this heading">#</a></h3>
<p>We provide two helper functions for plotting.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">plot_slice</span></code> plots a slice of the data. It shows the spike train along with the voltage traces for each channel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plot_waveforms</span></code> can be used to plot the waveforms for inferred spikes or the templates of a spike sorting model.</p></li>
</ul>
<div class="cell tag_:hide-cell: docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">plot_slice</span><span class="p">(</span><span class="n">traces</span><span class="p">:</span> <span class="n">Float</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_samples num_channels&quot;</span><span class="p">],</span>
               <span class="n">spike_times</span><span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes&quot;</span><span class="p">],</span>
               <span class="n">spike_ids</span><span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes&quot;</span><span class="p">],</span>
               <span class="n">start_time</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="n">end_time</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
               <span class="n">ylim</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">units</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\mu V$&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot a slice of the recording and the corresponding spike times.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    traces : torch.Tensor</span>
<span class="sd">        The voltage traces.</span>
<span class="sd">    spike_times : torch.Tensor</span>
<span class="sd">        The spike times, in samples.</span>
<span class="sd">    spike_ids : torch.Tensor</span>
<span class="sd">        The spike IDs, taking values 0,1,2,...,num_neurons-1</span>
<span class="sd">    start_time : float</span>
<span class="sd">        The start time of the slice, in seconds.</span>
<span class="sd">    end_time : float</span>
<span class="sd">        The end time of the slice, in seconds.</span>
<span class="sd">    spacing : float</span>
<span class="sd">        The relative spacing between the traces in the plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract constants</span>
    <span class="n">num_samples</span><span class="p">,</span> <span class="n">num_channels</span> <span class="o">=</span> <span class="n">traces</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">num_neurons</span> <span class="o">=</span> <span class="n">spike_ids</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Extract the slice of the recording</span>
    <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">SAMPLING_FREQUENCY</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">end_time</span> <span class="o">*</span> <span class="n">SAMPLING_FREQUENCY</span><span class="p">))</span>
    
    <span class="c1"># Get the y-limit for traces if not specified</span>
    <span class="k">if</span> <span class="n">ylim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ylim</span> <span class="o">=</span> <span class="mf">1.05</span> <span class="o">*</span> <span class="n">traces</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># Make an array of times in seconds</span>
    <span class="n">times_sec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span> <span class="o">/</span> <span class="n">SAMPLING_FREQUENCY</span>
    <span class="n">spike_times_sec</span> <span class="o">=</span> <span class="n">times_sec</span><span class="p">[</span><span class="n">spike_times</span><span class="p">]</span>
    <span class="n">spike_in_slice</span> <span class="o">=</span> <span class="p">(</span><span class="n">spike_times_sec</span> <span class="o">&gt;=</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spike_times_sec</span> <span class="o">&lt;=</span> <span class="n">end_time</span><span class="p">)</span>

    <span class="c1"># Plot the spike raster</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num_channels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_channels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spike_times_sec</span><span class="p">[</span><span class="n">spike_in_slice</span><span class="p">],</span> <span class="n">spike_ids</span><span class="p">[</span><span class="n">spike_in_slice</span><span class="p">],</span> <span class="s1">&#39;|k&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;neuron&quot;</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">))</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;spike train&quot;</span><span class="p">)</span>

    <span class="c1"># Plot the voltage traces </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
        <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times_sec</span><span class="p">[</span><span class="n">slc</span><span class="p">],</span> <span class="n">traces</span><span class="p">[</span><span class="n">slc</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;channel </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">ylim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">rf</span><span class="s2">&quot;trace [</span><span class="si">{</span><span class="n">units</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">num_channels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;time [sec]&quot;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_:hide-cell: docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">plot_waveforms</span><span class="p">(</span><span class="n">waveforms</span><span class="p">:</span> <span class="n">Float</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_waveforms windows_size num_channels&quot;</span><span class="p">],</span>
                   <span class="n">yunits</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;z-score&quot;</span><span class="p">,</span>
                   <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;waveform&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot a grid of spike waveforms or templates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    waveforms : torch.Tensor</span>
<span class="sd">        The waveforms (or templates) to plot.</span>

<span class="sd">    yunits : str</span>
<span class="sd">        The units of the y-axis. Default is &quot;z-score&quot;.</span>

<span class="sd">    name : str</span>
<span class="sd">        The name of the waveforms (or templates) to plot. Default is &quot;waveform&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_waveforms</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">num_channels</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">window_size</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">window_size</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">SAMPLING_FREQUENCY</span> <span class="o">*</span> <span class="mi">1000</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_waveforms</span><span class="p">,</span> 
                            <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">1.25</span> <span class="o">*</span> <span class="n">num_waveforms</span><span class="p">,</span> <span class="mf">1.25</span> <span class="o">*</span> <span class="n">num_channels</span><span class="p">),</span> 
                            <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">lim</span> <span class="o">=</span> <span class="mf">1.05</span> <span class="o">*</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_waveforms</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
            <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">[</span><span class="n">j</span><span class="p">,:,</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">lim</span><span class="p">,</span> <span class="n">lim</span><span class="p">)</span>
            <span class="c1"># axs[i,j].set_xlabel(&quot;time [samples]&quot;)</span>
            <span class="c1"># axs[i,j].set_title(f&quot;waveform {j}\n channel {i}&quot;)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;channel </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="s2"> [</span><span class="si">{</span><span class="n">yunits</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">num_channels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;time [ms]&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span>
</pre></div>
</div>
</div>
</div>
<p>Use the helper function to plot the first second of the data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">_</span> <span class="o">=</span> <span class="n">plot_slice</span><span class="p">(</span>
    <span class="n">traces</span><span class="p">,</span>
    <span class="n">true_spike_times</span><span class="p">,</span>
    <span class="n">true_spike_ids</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/a63c3718c1ce4e4119f0bce3c1cfc8e04a88ef0cd123fe82329d2170393b01f7.png" src="../_images/a63c3718c1ce4e4119f0bce3c1cfc8e04a88ef0cd123fe82329d2170393b01f7.png" />
</div>
</div>
<p>Now plot a 50 ms snippet so we can better see the voltage traces around each spike.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">_</span> <span class="o">=</span> <span class="n">plot_slice</span><span class="p">(</span>
    <span class="n">traces</span><span class="p">,</span>
    <span class="n">true_spike_times</span><span class="p">,</span>
    <span class="n">true_spike_ids</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="mf">0.65</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="mf">0.70</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/77ca1f7b8535a38e1851b4b62a67d2cf2b4f3cf057b9ae69eb2c7f4a44cb8d3d.png" src="../_images/77ca1f7b8535a38e1851b4b62a67d2cf2b4f3cf057b9ae69eb2c7f4a44cb8d3d.png" />
</div>
</div>
<p>Finally, plot the true templates for each neuron in this synthetic dataset.
Each time a neuron spikes, these templates are superimposed to create the traces above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plot_waveforms</span><span class="p">(</span><span class="n">true_templates</span><span class="p">,</span> <span class="n">yunits</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\mu V$&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;template&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;True neurons&#39; templates&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.05</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.05, &quot;True neurons&#39; templates&quot;)
</pre></div>
</div>
<img alt="../_images/7afd6dc4270a5e639373705cd3e651508e06eeee54f7ccf8f7cb2f3d61ccd3fd.png" src="../_images/7afd6dc4270a5e639373705cd3e651508e06eeee54f7ccf8f7cb2f3d61ccd3fd.png" />
</div>
</div>
<p>Notice that some neuron produce larger amplitude spikes than others. For example, neuron 4 produces large spikes on channel 3, whereas neuron 3 produces very small spikes.</p>
</section>
</section>
<section id="part-1-infer-spike-times">
<h2>Part 1: Infer spike times<a class="headerlink" href="#part-1-infer-spike-times" title="Link to this heading">#</a></h2>
<p>The next step of the process is to infer spike times by looking for pronounced dips in the voltage on at least one channel. In this simulated dataset, the noise on each channel has a standard deviation of about 10 <span class="math notranslate nohighlight">\(\mu\mathrm{V}\)</span>. To stand out from the noise, a spike should be about 4 standard deviations below the mean, or -40 <span class="math notranslate nohighlight">\(\mu\mathrm{V}\)</span> in magnitude. Moreover, spikes should be separated from one another by at least 3 ms.</p>
<section id="problem-1a-find-negative-peaks-in-the-data">
<h3>Problem 1a: Find negative peaks in the data<a class="headerlink" href="#problem-1a-find-negative-peaks-in-the-data" title="Link to this heading">#</a></h3>
<p>Use the <code class="docutils literal notranslate"><span class="pre">signal.find_peaks</span></code> function to extract negative peaks on at least one channel. A simple way to do so is to compute the minimum value across channels for each time step, then negate that signal and look for peaks that match the heigh and distance criteria described above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">inferred_spike_times</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span>
    <span class="o">-</span><span class="n">traces</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
    <span class="n">distance</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.003</span> <span class="o">*</span> <span class="n">SAMPLING_FREQUENCY</span><span class="p">),</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">40</span>
    <span class="p">)</span>

<span class="n">inferred_spike_times</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">inferred_spike_times</span><span class="p">)</span>
<span class="n">num_inferred_spikes</span> <span class="o">=</span> <span class="n">inferred_spike_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the inferred spike times with dummy spike ids</span>
<span class="n">dummy_spike_ids</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">inferred_spike_times</span><span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">plot_slice</span><span class="p">(</span>
    <span class="n">traces</span><span class="p">,</span>
    <span class="n">inferred_spike_times</span><span class="p">,</span>
    <span class="n">dummy_spike_ids</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">units</span><span class="o">=</span><span class="s2">&quot;z score&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/2d6cf026595b8d1aae05cee32a65fc11424e0dfd38602b52b0c9afac558504e8.png" src="../_images/2d6cf026595b8d1aae05cee32a65fc11424e0dfd38602b52b0c9afac558504e8.png" />
</div>
</div>
</section>
<section id="problem-1b-evaluate-the-inferred-spike-times">
<h3>Problem 1b: Evaluate the inferred spike times<a class="headerlink" href="#problem-1b-evaluate-the-inferred-spike-times" title="Link to this heading">#</a></h3>
<p>To evaluate the inferred spikes, let’s think of it as a binary classification problem.
First, construct a binary tensor of length <code class="docutils literal notranslate"><span class="pre">NUM_SAMPLES</span> <span class="pre">/</span> <span class="pre">WINDOW_SIZE</span></code> that specifies if
there was a true spike (from any neuron) in each window of time. Then construct an analogous
binary tensor for the inferred spike times. If a true spike and an inferred spike are present
in the same window, the inferred spike is a <em>true positive</em>. If there is an inferred spike but
not true spike in the same window, then it’s a <em>false positive</em>. True and false negatives are
defined similarly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">evaluate_inferred_spikes</span><span class="p">(</span>
        <span class="n">inferred_spike_times</span><span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_inferred_spikes&quot;</span><span class="p">],</span>
        <span class="n">true_spike_times</span><span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_true_spikes&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the inferred spike times against the true spike times.</span>
<span class="sd">    We count a inferred spike as a true positive if it is within</span>
<span class="sd">    window_size seconds of a true spike. We count a true spike</span>
<span class="sd">    as a false negative if it is not within window_size seconds</span>
<span class="sd">    of a inferred spike. False positives and true negatives are </span>
<span class="sd">    defined similarly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inferred_spike_times : torch.Tensor</span>
<span class="sd">        The inferred spike times, in samples.</span>
<span class="sd">    true_spike_times : torch.Tensor</span>
<span class="sd">        The true spike times, in samples.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a boolean tensors to mark true spikes</span>
    <span class="n">true_spike_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">NUM_SAMPLES</span> <span class="o">//</span> <span class="n">WINDOW_SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">true_spike_mask</span><span class="p">[</span><span class="n">true_spike_times</span> <span class="o">//</span> <span class="n">WINDOW_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="c1"># Create a boolean tensors to mark inferred spikes</span>
    <span class="n">inferred_spike_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">NUM_SAMPLES</span> <span class="o">//</span> <span class="n">WINDOW_SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">inferred_spike_mask</span><span class="p">[</span><span class="n">inferred_spike_times</span> <span class="o">//</span> <span class="n">WINDOW_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="c1"># Count true positives, false positives, false negatives, and true negatives</span>
    <span class="n">tp</span> <span class="o">=</span> <span class="p">(</span><span class="n">true_spike_mask</span> <span class="o">&amp;</span> <span class="n">inferred_spike_mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">inferred_spike_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">true_spike_mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">inferred_spike_mask</span> <span class="o">&amp;</span> <span class="n">true_spike_mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">inferred_spike_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">true_spike_mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="c1"># Return some summary statistics of this binary classifier</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tp</span><span class="o">=</span><span class="n">tp</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">fp</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="n">fn</span><span class="p">,</span> <span class="n">tn</span><span class="o">=</span><span class="n">tn</span><span class="p">)</span>
    
<span class="n">perf_stats</span> <span class="o">=</span> <span class="n">evaluate_inferred_spikes</span><span class="p">(</span>
    <span class="n">inferred_spike_times</span><span class="p">,</span>
    <span class="n">true_spike_times</span>
<span class="p">)</span>
    
</pre></div>
</div>
</div>
</div>
<p>Now print the number of true positives (<span class="math notranslate nohighlight">\(TP\)</span>), false positives (<span class="math notranslate nohighlight">\(FP\)</span>), false negatives (<span class="math notranslate nohighlight">\(FN\)</span>), and true negatives (<span class="math notranslate nohighlight">\(TN\)</span>).</p>
<p>Based on these statistics, compute and print the precision and recall the spike detector,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathrm{precision} &amp;= \frac{TP}{TP + FP} \\
\mathrm{recall} &amp;= \frac{TP}{TP + FN}
\end{align*}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;True Positives:  </span><span class="si">{</span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;False Positives: </span><span class="si">{</span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;False Negatives: </span><span class="si">{</span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;True Negatives:  </span><span class="si">{</span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recall:          </span><span class="si">{</span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Precision:       </span><span class="si">{</span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">perf_stats</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True Positives:  2153
False Positives: 402
False Negatives: 526
True Negatives:  20919

Recall:          0.80
Precision:       0.84
</pre></div>
</div>
</div>
</div>
</section>
<section id="collect-the-voltage-traces-surrounding-each-inferred-spike">
<h3>Collect the voltage traces surrounding each inferred spike<a class="headerlink" href="#collect-the-voltage-traces-surrounding-each-inferred-spike" title="Link to this heading">#</a></h3>
<p>Next, extract a window of the voltage trace surrounding each inferred spike.
We use a simple for loop to fill in the waveforms one at a time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spike_waveforms</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_inferred_spikes</span><span class="p">,</span> <span class="n">WINDOW_SIZE</span><span class="p">,</span> <span class="n">NUM_CHANNELS</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inferred_spike_times</span><span class="p">):</span>
    <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">WINDOW_SIZE</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">WINDOW_SIZE</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">spike_waveforms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot a few of the waveforms</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plot_waveforms</span><span class="p">(</span><span class="n">spike_waveforms</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="n">yunits</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\mu V$&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;waveform&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;First 5 inferred spike waveforms&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.05</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.05, &#39;First 5 inferred spike waveforms&#39;)
</pre></div>
</div>
<img alt="../_images/d814448d2acc7d217acf4bffc8a72ab0ac3c63583518251e154300a5b4d7f786.png" src="../_images/d814448d2acc7d217acf4bffc8a72ab0ac3c63583518251e154300a5b4d7f786.png" />
</div>
</div>
</section>
</section>
<section id="part-2-simple-spike-sorting">
<h2>Part 2: Simple Spike Sorting<a class="headerlink" href="#part-2-simple-spike-sorting" title="Link to this heading">#</a></h2>
<p>Now let’s write a simple spike sorting algorithm to cluster the spikes based on their waveforms!</p>
<p>Let <span class="math notranslate nohighlight">\(\mathbf{X}_s \in \mathbb{R}^{D \times C}\)</span> denote the waveform of spike <span class="math notranslate nohighlight">\(s\)</span>. It is <span class="math notranslate nohighlight">\(D\)</span> samples long and <span class="math notranslate nohighlight">\(C\)</span> channels wide, with entries denoted by,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbf{X}_s = 
\begin{bmatrix}
x_{s,1,1} &amp; \cdots &amp; x_{s,1,C} \\
\vdots &amp; &amp; \vdots \\
x_{s,D,1} &amp; \cdots &amp; x_{s,D,C} 
\end{bmatrix}
\end{align*} \]</div>
<p>Assume each spike waveform can be attributed to one of <span class="math notranslate nohighlight">\(N\)</span> neurons.
Each neuron <span class="math notranslate nohighlight">\(n=1,\ldots,N\)</span> is associated with a template, <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_n \in \mathbb{R}^{D \times C}\)</span> with entries,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\boldsymbol{\mu}_n = 
\begin{bmatrix}
\mu_{n,1,1} &amp; \cdots &amp; \mu_{n,1,C} \\
\vdots &amp; &amp; \vdots \\
\mu_{n,D,1} &amp; \cdots &amp; \mu_{n,D,C} 
\end{bmatrix}
\end{align*} \]</div>
<p>Let <span class="math notranslate nohighlight">\(z_s \in \{1,\ldots, N\}\)</span> be a latent variable that specifies which neuron produced spike <span class="math notranslate nohighlight">\(s\)</span>.
We assume that each spike waveform equal to the template of the neuron that produced it, plus Gaussian noise,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbf{X}_s &amp;= \boldsymbol{\mu}_{z_s} + \boldsymbol{\epsilon}_s,
\end{align*}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{\epsilon}_s \in \mathbb{R}^{D \times C}\)</span> is a matrix of iid Gaussian random variables, each with mean zero and variance <span class="math notranslate nohighlight">\(\sigma^2\)</span>.</p>
<p>In other words, we assume a Gaussian likelihood model of the form,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
p(\mathbf{X}_s \mid z_s = n) 
&amp;= \prod_{d=1}^D \prod_{c=1}^C 
\mathcal{N}(x_{s,d,c} \mid \mu_{n,d,c}, \sigma^2).
\end{align*}\]</div>
<p>where</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathcal{N}(x \mid \mu, \sigma^2) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-\frac{1}{2 \sigma^2}(x - \mu)^2}
\end{align*}\]</div>
<p>is the probability density function (pdf) of a Gaussian distribution with mean <span class="math notranslate nohighlight">\(\mu\)</span> and variance <span class="math notranslate nohighlight">\(\sigma^2\)</span> evaluated at a point <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>To fit the model, we need to infer the latent spike IDs <span class="math notranslate nohighlight">\(z_s\)</span> for <span class="math notranslate nohighlight">\(s=1,\ldots,S\)</span>, as well as the templates <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_n\)</span> for <span class="math notranslate nohighlight">\(n=1,\ldots,N\)</span>.</p>
<section id="problem-2a-deriving-the-fitting-algorithm">
<h3>Problem 2a: Deriving the fitting algorithm<a class="headerlink" href="#problem-2a-deriving-the-fitting-algorithm" title="Link to this heading">#</a></h3>
<p>We will fit the model by maximizing the log probability with respect to the latent variables, <span class="math notranslate nohighlight">\(z_s\)</span>, and the templates, <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_n\)</span>. In particular, we will use coordinate ascent, alternating between updating the latent variables while keeping the templates fixed, and then updating the templates given the latent variables.</p>
<p>Let</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{X} = \{\mathbf{X}_s\}_{s=1}^S\)</span> denote the set of all spike waveforms,</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{z} = \{z_s\}_{s=1}^S\)</span> denote the set of spike assignments, and</p></li>
<li><p><span class="math notranslate nohighlight">\(\boldsymbol{\mu} = \{\boldsymbol{\mu}_n\}_{n=1}^N\)</span> denote the set of all templates.</p></li>
</ul>
<p>The log probability is,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\log p(\mathbf{X}, \mathbf{z} \mid \boldsymbol{\mu})
&amp;= \sum_{s=1}^S \log p(\mathbf{X}_s \mid z_s) + \log p(z_s)
\end{align*}\]</div>
<p>Assume that all spike assignments are equally probable under the prior, so that <span class="math notranslate nohighlight">\(p(z_s = n) = \frac{1}{N}\)</span> and <span class="math notranslate nohighlight">\(\log p(z_s) = -\log N\)</span> always. Then, substituting the likelihood above, we have the following objective function,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
L(\mathbf{z}, \boldsymbol{\mu}) 
&amp;\triangleq \log p(\mathbf{X}, \mathbf{z} \mid \boldsymbol{\mu}) \\
&amp;= \sum_{s=1}^S \sum_{d=1}^D \sum_{c=1}^C \log \mathcal{N}(x_{s,c,d} \mid \mu_{z_s,c,d}, \sigma^2) + \mathrm{const}
\end{align*}\]</div>
<p>First, show that if you fix the spike assignments, <span class="math notranslate nohighlight">\(\mathbf{z}\)</span>, the log probability is maximized by setting,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mu_{n,d,c} &amp;= \frac{1}{S_n} \sum_{s:z_s = n} x_{s,c,d}
\end{align*}\]</div>
<p>where <span class="math notranslate nohighlight">\(S_n = \sum_s \mathbb{I}[z_s=n]\)</span> is the number of spikes assigned to neuron <span class="math notranslate nohighlight">\(n\)</span>.</p>
<hr class="docutils" />
<p><em>Your answer here</em></p>
</section>
<hr class="docutils" />
<section id="problem-2b-updating-the-spike-assignments">
<h3>Problem 2b: Updating the spike assignments<a class="headerlink" href="#problem-2b-updating-the-spike-assignments" title="Link to this heading">#</a></h3>
<p>Next, show that when you fix the templates, the log probability is optimized by setting,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
z_s &amp;= \arg \max_n \; \sum_{d=1}^D \sum_{c=1}^C \log \mathcal{N}(x_{s,c,d} \mid \mu_{n,c,d}, \sigma^2).
\end{align*}\]</div>
<p>Or equivalently,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
z_s &amp;= \arg \min_n \; \|\mathbf{X}_s - \boldsymbol{\mu}_n\|_F^2.
\end{align*}\]</div>
<p>where <span class="math notranslate nohighlight">\(\|\mathbf{A}\|_F^2 = \sum_{d=1}^D \sum_{c=1}^C a_{d,c}^2\)</span> is the squared Frobenius norm of a matrix <span class="math notranslate nohighlight">\(\mathbf{A} \in \mathbb{R}^{D \times C}\)</span>.</p>
<hr class="docutils" />
<p><em>Your answer here</em></p>
</section>
<hr class="docutils" />
<section id="problem-2c-implement-the-model-and-algorithm">
<h3>Problem 2c: Implement the model and algorithm<a class="headerlink" href="#problem-2c-implement-the-model-and-algorithm" title="Link to this heading">#</a></h3>
<p>Complete the starter code below to implement this simple spike sorting model and algorithm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SimpleSpikeSorter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple spike sorter that uses a Gaussian mixture model (GMM) to fit the templates.</span>
<span class="sd">    The GMM is fit to the putative spike waveforms using coordinate ascent on the </span>
<span class="sd">    log joint probability of the model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    initial_templates : torch.Tensor</span>
<span class="sd">        The initial templates for the GMM, with shape (num_neurons, window_size, num_channels).</span>

<span class="sd">    noise_scale : float</span>
<span class="sd">        The scale of the noise in the GMM. This is used to compute the log likelihood of</span>
<span class="sd">        the spike waveforms given the templates. The noise scale is assumed to be the same</span>
<span class="sd">        for all neurons, samples, and channels. Note that the scale is the standard deviation</span>
<span class="sd">        of the noise, not the variance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">templates</span><span class="p">:</span> <span class="n">Float</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_neurons window_size num_channels&quot;</span><span class="p">]</span>
    <span class="n">noise_scale</span><span class="p">:</span> <span class="nb">float</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">initial_templates</span><span class="p">:</span> <span class="n">Float</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_neurons window_size num_channels&quot;</span><span class="p">],</span>
            <span class="n">noise_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="n">initial_templates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise_scale</span> <span class="o">=</span> <span class="n">noise_scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_neurons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">log_probability</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">spike_waveforms</span><span class="p">:</span> <span class="n">Float</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes window_size num_channels&quot;</span><span class="p">],</span>
            <span class="n">spike_ids</span><span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the log probability of the spike waveforms given the templates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute the log likelihood of each spike waveform given each template</span>
        <span class="n">lls</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span>
            <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">spike_ids</span><span class="p">],</span>
            <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_scale</span>
        <span class="p">)</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">spike_waveforms</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Compute the average log likelihood</span>
        <span class="k">return</span> <span class="n">lls</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update_templates</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">spike_waveforms</span><span class="p">:</span> <span class="n">Float</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes window_size num_channels&quot;</span><span class="p">],</span>
            <span class="n">spike_ids</span><span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes&quot;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the templates using the spike waveforms and spike IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neurons</span><span class="p">):</span>
            <span class="c1"># Get the spike waveforms for this neuron</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">spike_waveforms</span><span class="p">[</span><span class="n">spike_ids</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update_spike_ids</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">spike_waveforms</span><span class="p">:</span> <span class="n">Float</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes window_size num_channels&quot;</span><span class="p">],</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the spike IDs using the templates and spike waveforms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute the log likelihood of each spike waveform given each template</span>
        <span class="n">lls</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span>
            <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:],</span>
            <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_scale</span>
        <span class="p">)</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">spike_waveforms</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Assign each spike waveform to the template with the highest log likelihood</span>
        <span class="k">return</span> <span class="n">lls</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
            <span class="n">spike_waveforms</span><span class="p">:</span> <span class="n">Float</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes window_size num_channels&quot;</span><span class="p">],</span>
            <span class="n">num_iterations</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Float</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_iterations&quot;</span><span class="p">],</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_spikes&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the GMM to the spike waveforms using coordinate ascent on the log joint probability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the spike IDs</span>
        <span class="n">spike_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_spike_ids</span><span class="p">(</span><span class="n">spike_waveforms</span><span class="p">)</span>

        <span class="c1"># Iterate to update the templates and spike IDs</span>
        <span class="n">lps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">itr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
            <span class="n">lps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_probability</span><span class="p">(</span><span class="n">spike_waveforms</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;iteration </span><span class="si">{</span><span class="n">itr</span><span class="si">}</span><span class="s2">: log probability = </span><span class="si">{</span><span class="n">lps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Update the templates and spike IDs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_templates</span><span class="p">(</span><span class="n">spike_waveforms</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">)</span>
            <span class="n">spike_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_spike_ids</span><span class="p">(</span><span class="n">spike_waveforms</span><span class="p">)</span>

        <span class="c1"># Return the final spike IDs</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">lps</span><span class="p">),</span> <span class="n">spike_ids</span>
</pre></div>
</div>
</div>
</div>
<p>Run the coordinate ascent algorithm to fit the model!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_neurons</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c1"># Initialize the spike sorter with random templates</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">220</span><span class="p">)</span>
<span class="n">initial_templates</span> <span class="o">=</span> <span class="n">spike_waveforms</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_inferred_spikes</span><span class="p">,</span> <span class="p">(</span><span class="n">num_neurons</span><span class="p">,))]</span>
<span class="n">spike_sorter</span> <span class="o">=</span> <span class="n">SimpleSpikeSorter</span><span class="p">(</span><span class="n">initial_templates</span><span class="p">)</span>

<span class="c1"># Fit the spike sorter to the putative spike waveforms</span>
<span class="n">lps</span><span class="p">,</span> <span class="n">inferred_spike_ids</span> <span class="o">=</span> <span class="n">spike_sorter</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="n">spike_waveforms</span><span class="p">,</span>
    <span class="n">num_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>iteration 0: log probability = -2638.94
iteration 1: log probability = -2276.83
iteration 2: log probability = -2253.49
iteration 3: log probability = -2252.00
iteration 4: log probability = -2251.27
iteration 5: log probability = -2251.19
iteration 6: log probability = -2251.19
iteration 7: log probability = -2251.19
iteration 8: log probability = -2251.19
iteration 9: log probability = -2251.19
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lps</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;iteration&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;log probability&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;log probability&#39;)
</pre></div>
</div>
<img alt="../_images/a37d2a11c1b2631fa22fb97bed5cdc3b219881aace9a2ada29e40d51c1e69b49.png" src="../_images/a37d2a11c1b2631fa22fb97bed5cdc3b219881aace9a2ada29e40d51c1e69b49.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plot_waveforms</span><span class="p">(</span><span class="n">spike_sorter</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span> <span class="n">yunits</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\mu V$&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;template&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Inferred templates&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.05</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.05, &#39;Inferred templates&#39;)
</pre></div>
</div>
<img alt="../_images/a81d9b862021fee2e7d5a346c41978fbda1b6995b7d1ce1fa564c762608e5d9c.png" src="../_images/a81d9b862021fee2e7d5a346c41978fbda1b6995b7d1ce1fa564c762608e5d9c.png" />
</div>
</div>
</section>
<section id="compare-ids-of-the-true-neurons-that-match-each-inferred-spike">
<h3>Compare IDs of the true neurons that match each inferred spike<a class="headerlink" href="#compare-ids-of-the-true-neurons-that-match-each-inferred-spike" title="Link to this heading">#</a></h3>
<p>The function below computes the identities of the true neurons corresponding
to each inferred spike. For each inferred spike time, first determine if there
is a true spike within a small window of that time. If so, find the ID of the true
neuron that generated that spike. Otherwise, declare the inferred spike to be a false
positive, indicated by -1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">match_true_and_inferred_spikes</span><span class="p">(</span>
        <span class="n">inferred_spike_times</span><span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_inferred_spikes&quot;</span><span class="p">],</span>
        <span class="n">true_spike_times</span><span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_true_spikes&quot;</span><span class="p">],</span>
        <span class="n">true_spike_ids</span><span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_true_spikes&quot;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;num_inferred_spikes&quot;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Match the inferred spike times to the true spike times.</span>
<span class="sd">    For each inferred spike, find the closest true spike within a window size.</span>
<span class="sd">    If the closest true spike is within the window size, assign the inferred spike</span>
<span class="sd">    to the true spike ID. If not, assign the inferred spike to -1 (no match).</span>
<span class="sd">    The matching is done with a simple for loop, which is not efficient for large</span>
<span class="sd">    spike trains. However, it is simple and easy to understand.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inferred_spike_times : torch.Tensor</span>
<span class="sd">        The inferred spike times, in samples.</span>
<span class="sd">    true_spike_times : torch.Tensor</span>
<span class="sd">        The true spike times, in samples.</span>
<span class="sd">    true_spike_ids : torch.Tensor</span>
<span class="sd">        The true spike IDs, taking values 0,1,2,...,true_num_neurons-1</span>
<span class="sd">    window_size : int</span>
<span class="sd">        The window size, in samples.</span>
<span class="sd">    sampling_frequency : int</span>
<span class="sd">        The sampling frequency of the recording.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matching_spike_ids : torch.Tensor</span>
<span class="sd">        The IDs of the true neurons that produced the inferred spike.</span>
<span class="sd">        The tensor takes values -1,0,1,2,...,num_neurons-1, where -1 indicates </span>
<span class="sd">        that the inferred spike does not match any true spike within the window size.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For each inferred spike, find the closest true spike</span>
    <span class="n">matching_spike_ids</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">inferred_spike_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inferred_time</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inferred_spike_times</span><span class="p">):</span>
        <span class="c1"># Find the closest true spike within the window size</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">true_spike_times</span> <span class="o">-</span> <span class="n">inferred_time</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="n">WINDOW_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">matching_spike_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_spike_ids</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">matching_spike_ids</span>

<span class="n">matching_spike_ids</span> <span class="o">=</span> <span class="n">match_true_and_inferred_spikes</span><span class="p">(</span>
    <span class="n">inferred_spike_times</span><span class="p">,</span>
    <span class="n">true_spike_times</span><span class="p">,</span>
    <span class="n">true_spike_ids</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-2d-compare-the-true-and-inferred-spike-assignments">
<h3>Problem 2d: Compare the true and inferred spike assignments<a class="headerlink" href="#problem-2d-compare-the-true-and-inferred-spike-assignments" title="Link to this heading">#</a></h3>
<p>Create a confusion matrix that counts how many times each inferred spike assignment
was matched to either a false positive (-1) or a true neuron <span class="math notranslate nohighlight">\(n\)</span> for <span class="math notranslate nohighlight">\(n=1,\ldots,N_{\mathsf{true}}\)</span>.</p>
<p>Show this confusion matrix using <code class="docutils literal notranslate"><span class="pre">plt.imshow</span></code>. Remember to label your axes and include a colorbar!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Count the number of times each inferred neuron matched a spike from each true neuron</span>
<span class="c1"># or was a false positive.</span>
<span class="n">confusion_matrix</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_neurons</span><span class="p">,</span> <span class="n">TRUE_NUM_NEURONS</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">):</span>
    <span class="n">confusion_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">matching_spike_ids</span><span class="p">[</span><span class="n">inferred_spike_ids</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">TRUE_NUM_NEURONS</span><span class="p">):</span>
        <span class="n">confusion_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">matching_spike_ids</span><span class="p">[</span><span class="n">inferred_spike_ids</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="c1"># Plot the counts</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Blues&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">TRUE_NUM_NEURONS</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> 
           <span class="p">[</span><span class="s2">&quot;FP&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">TRUE_NUM_NEURONS</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;true neuron&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;inferred neuron&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;number of spikes&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Confusion Matrix&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0.98, &#39;Confusion Matrix&#39;)
</pre></div>
</div>
<img alt="../_images/b0bc7251c9bb9f8c5699a16cc4c3b3b4c1a195ef5d66599b7df812469dbfe369.png" src="../_images/b0bc7251c9bb9f8c5699a16cc4c3b3b4c1a195ef5d66599b7df812469dbfe369.png" />
</div>
</div>
</section>
</section>
<section id="part-3-generalizations">
<h2>Part 3: Generalizations<a class="headerlink" href="#part-3-generalizations" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>How would you change the model to account for neurons that have different firing rates?</p></li>
<li><p>How would you generalize this model if spikes from the same neuron could have different amplitudes? That is, on average <span class="math notranslate nohighlight">\(\mathbf{X}_s\)</span> equals the template <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_{z_s}\)</span>, but they can be scaled up or down by a random number <span class="math notranslate nohighlight">\(a_s &gt; 0\)</span>. Describe how you would update your model to allow for this extra form of variability.</p></li>
<li><p>Here we assumed that we knew the number of neurons, but of course that’s unrealistic. How would you estimate the number of neurons in a data-driven manner?</p></li>
</ol>
</section>
<section id="submission-instructions">
<h2>Submission Instructions<a class="headerlink" href="#submission-instructions" title="Link to this heading">#</a></h2>
<p><em>TODO</em></p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./labs"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="00_pytorch_primer.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">PyTorch Primer</p>
      </div>
    </a>
    <a class="right-next"
       href="01b_spike_sorting_deconv.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Spike Sorting by Deconvolution</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setup">Setup</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#load-the-data">Load the data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#helper-functions">Helper functions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-1-infer-spike-times">Part 1: Infer spike times</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-1a-find-negative-peaks-in-the-data">Problem 1a: Find negative peaks in the data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-1b-evaluate-the-inferred-spike-times">Problem 1b: Evaluate the inferred spike times</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#collect-the-voltage-traces-surrounding-each-inferred-spike">Collect the voltage traces surrounding each inferred spike</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-2-simple-spike-sorting">Part 2: Simple Spike Sorting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2a-deriving-the-fitting-algorithm">Problem 2a: Deriving the fitting algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2b-updating-the-spike-assignments">Problem 2b: Updating the spike assignments</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2c-implement-the-model-and-algorithm">Problem 2c: Implement the model and algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#compare-ids-of-the-true-neurons-that-match-each-inferred-spike">Compare IDs of the true neurons that match each inferred spike</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2d-compare-the-true-and-inferred-spike-assignments">Problem 2d: Compare the true and inferred spike assignments</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-3-generalizations">Part 3: Generalizations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#submission-instructions">Submission Instructions</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Scott Linderman
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>